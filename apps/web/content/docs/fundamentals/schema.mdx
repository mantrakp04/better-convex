---
title: Schema Design
description: Define your database schema with Convex validators
---

# Schema Design

Convex uses a schema to define your database structure. This template uses Convex Ents for enhanced type safety and relationships, combined with Zod schemas for validation.

## Schema Structure

The schema is organized with each table defined in its own file under `tables/`:

```ts
// schema.ts
import { defineEntSchema, getEntDefinitions } from "convex-ents";
import { todosEnt } from "./tables/todos";
import { todoAssignedUsersEnt } from "./tables/todoAssignedUsers";

const schema = defineEntSchema({
  todos: todosEnt,
  todoAssignedUsers: todoAssignedUsersEnt,
});

export default schema;
export const entDefinitions = getEntDefinitions(schema);
```

## Validators

Convex provides built-in validators for type safety:

| Validator | TypeScript Type | Description |
|-----------|-----------------|-------------|
| `v.string()` | `string` | String value |
| `v.number()` | `number` | Number (int or float) |
| `v.boolean()` | `boolean` | Boolean value |
| `v.null()` | `null` | Null value |
| `v.id("tableName")` | `Id<"tableName">` | Reference to another document |
| `v.array(v.string())` | `string[]` | Array of values |
| `v.object({...})` | `{...}` | Nested object |
| `v.optional(v.string())` | `string \| undefined` | Optional field |
| `v.union(v.literal("a"), v.literal("b"))` | `"a" \| "b"` | Union type |

## Indexes

Indexes are crucial for query performance. Define them on your table:

```ts
const todosTable = Todos.table
  // Composite indexes with sort field last
  .index("organizationId_userId", ["organizationId", "userId", "updatedAt"])
  .index("organizationId", ["organizationId", "updatedAt"])
  .index("organizationId_teamId", ["organizationId", "teamId", "updatedAt"])
  // Single-field index
  .index("userId", ["userId"]);
```

### Index Usage Guidelines

1. **Query by exact match**: Index fields in the order you filter them
2. **Range queries**: Put the range field last in the index
3. **Sorting**: Include sort fields (like `updatedAt`) after filter fields for efficient ordering

```ts
// This query uses "organizationId" index with updatedAt for sorting
ctx.db.query("todos")
  .withIndex("organizationId", (q) =>
    q.eq("organizationId", orgId)
  )
  .order("desc") // Orders by updatedAt (last field in index)
  .collect();
```

## Defining Tables with Zod

This template uses Zod schemas with `convex-helpers` to define fields, providing both runtime validation and type inference:

```ts
// tables/todos.ts
import { z } from "zod";
import { defineEntFromTable } from "convex-ents";
import { Table } from "convex-helpers/server";
import { zodToConvexFields } from "convex-helpers/server/zod4";

export const todosZodSchema = {
  organizationId: z.string(),
  userId: z.string(),
  teamId: z.string().optional(),
  title: z.string(),
  description: z.string().optional(),
  status: z.enum(["todo", "in_progress", "done"]).default("todo"),
  dueDate: z.number().nullable().optional(),
  startTime: z.number().nullable().optional(),
  endTime: z.number().nullable().optional(),
  priority: z.enum(["low", "medium", "high"]).default("medium"),
  updatedAt: z.number(),
};

// Convert Zod schema to Convex fields
export const todosFields = zodToConvexFields(todosZodSchema);

// Create a Table helper for type-safe queries
export const Todos = Table("todos", todosFields);

// Define indexes and edges
const todosTable = Todos.table
  .index("organizationId_userId", ["organizationId", "userId", "updatedAt"])
  .index("organizationId", ["organizationId", "updatedAt"])
  .index("organizationId_teamId", ["organizationId", "teamId", "updatedAt"])
  .index("userId", ["userId"]);

export const todosEnt = defineEntFromTable(todosTable)
  .edges("assignedUsers", { to: "todoAssignedUsers", ref: "todoId" });
```

## Junction Tables

For many-to-many relationships, define a junction table:

```ts
// tables/todoAssignedUsers.ts
import { z } from "zod";
import { defineEntFromTable } from "convex-ents";
import { Table } from "convex-helpers/server";
import { zodToConvexFields } from "convex-helpers/server/zod4";
import { v } from "convex/values";

export const todoAssignedUsersZodSchema = {
  userId: z.string(),
  assignedBy: z.string(),
};

export const todoAssignedUsersFields = {
  ...zodToConvexFields(todoAssignedUsersZodSchema),
  todoId: v.id("todos"),
};

export const TodoAssignedUsers = Table("todoAssignedUsers", todoAssignedUsersFields);

const todoAssignedUsersTable = TodoAssignedUsers.table
  .index("userId", ["userId"])
  .index("todoId_userId", ["todoId", "userId"]);

export const todoAssignedUsersEnt = defineEntFromTable(todoAssignedUsersTable)
  .edge("todo", { to: "todos", field: "todoId" });
```

## Generated Types

After defining your schema, Convex generates TypeScript types:

```ts
// _generated/dataModel.d.ts
export type Doc<TableName extends TableNames> = {
  todos: {
    _id: Id<"todos">;
    _creationTime: number;
    title: string;
    status: "todo" | "in_progress" | "done";
    priority: "low" | "medium" | "high";
    // ... other fields
  };
};
```

Use these types in your code:

```ts
import { Doc, Id } from "./_generated/dataModel";

type Todo = Doc<"todos">;
type TodoId = Id<"todos">;
```

## Schema Migrations

Convex enforces that your schema must always match existing data. Use the `@convex-dev/migrations` component for safe, resumable migrations.

### Safe Schema Changes

1. **Adding fields**: Add with `v.optional()` first, backfill data, then make required
2. **Removing fields**: Mark as `v.optional()`, remove data from documents, then remove from schema
3. **Changing types**: Use `v.union()` of old and new types, migrate data, then update to new type only

### Using the Migrations Component

```ts
// convex/migrations.ts
import { Migrations } from "@convex-dev/migrations";
import { components } from "./_generated/api";

export const migrations = new Migrations(components.migrations);

// Define a migration to backfill updatedAt
export const backfillUpdatedAt = migrations.define({
  table: "todos",
  migrateOne: (ctx, doc) => {
    if (!doc.updatedAt) {
      return { updatedAt: doc._creationTime };
    }
  },
});

// Define a migration to clear an optional field
export const clearField = migrations.define({
  table: "todos",
  batchSize: 10, // Customize batch size for large documents
  migrateOne: () => ({ optionalField: undefined }),
});
```

### Running Migrations

```ts
// Run a single migration
await migrations.runOne(ctx, internal.migrations.backfillUpdatedAt);

// Override batch size for specific runs
await migrations.runOne(ctx, internal.migrations.clearField, {
  batchSize: 1,
});
```

The migrations component handles batching, resumption from failures, and dry runs for validation.

Next, learn about [Zod Validation](/docs/fundamentals/zod-validation).
